<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[菜鸟小院]]></title>
  <subtitle><![CDATA[杜龙龙的博客]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.dullong.com/"/>
  <updated>2016-01-03T08:23:42.000Z</updated>
  <id>http://www.dullong.com/</id>
  
  <author>
    <name><![CDATA[dll]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在浏览器端使用jade]]></title>
    <link href="http://www.dullong.com/use-jade-on-the-browser-side.html"/>
    <id>http://www.dullong.com/use-jade-on-the-browser-side.html</id>
    <published>2016-01-03T07:30:26.000Z</published>
    <updated>2016-01-03T08:23:42.000Z</updated>
    <content type="html"><![CDATA[<p>Jade 是一个高性能的模板引擎，它深受 <a href="http://haml-lang.com" target="_blank" rel="external">Haml</a> 影响，它是用 JavaScript 实现的, 并且可以供 <a href="http://nodejs.org" target="_blank" rel="external">Node</a> 使用.</p>
<blockquote>
<p>由于版权原因，jade更名为pug，详见<a href="https://github.com/pugjs/jade/issues/2184" target="_blank" rel="external">issue</a></p>
</blockquote>
<p>本文不介绍如何在node端使用jade,具体使用方法可见官方文档或express文档。</p>
<p>在某些情况下，我们并不需要总是在后端去渲染模板。比如当我们编写一篇文章而又没有写完时，我们仅仅是想看一下预览效果，不希望去请求服务端保存，这时就要求预览的模板与样式与我们后端的一样，这种情况下就用到了在浏览器端进行渲染。</p>
<a id="more"></a>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了保持结构和效果的统一，我们需要用到和后端一样的模板文件。最直接的方法就是使用线上的<code>filename.jade</code>模板。而一般情况下，在浏览器端，我们是访问不到我们编写的这些模板文件的。</p>
<p>有两种方法去解决此问题：</p>
<ul>
<li>将我们需要用到的模板文件拷贝到<code>public</code>文件夹内（假设浏览器端可以访问此目录）。</li>
<li>将模板文件编译成一个js文件，然后在浏览器端调用渲染html</li>
</ul>
<h2 id="u524D_u7AEF_u6E32_u67D3jade_u6A21_u677F_u6587_u4EF6"><a href="#u524D_u7AEF_u6E32_u67D3jade_u6A21_u677F_u6587_u4EF6" class="headerlink" title="前端渲染jade模板文件"></a>前端渲染jade模板文件</h2><p>最新版本的jade和最新版本的浏览器才支持此特性。并且一个独立的运行环境特别大(v1.11.0大小为260K+)。官方不建议使用此种方法，本文也不赘述，详见官方文档。</p>
<h2 id="u9884_u7F16_u8BD1jade_u6A21_u677F_u6587_u4EF6"><a href="#u9884_u7F16_u8BD1jade_u6A21_u677F_u6587_u4EF6" class="headerlink" title="预编译jade模板文件"></a>预编译jade模板文件</h2><p>官方建议将jade模板文件进行预编译，然后在浏览器端仅仅使用<code>runtime.js</code>，此版本大小为7k。</p>
<p>首先我们需要全局安装<code>jade</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> jade</span></span><br></pre></td></tr></table></figure>
<p>使用如下命令编译需要编译的模板文件(filename.jade)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jade</span> --client --<span class="built_in">no</span>-<span class="built_in">debug</span> filename.jade</span><br></pre></td></tr></table></figure>
<p>然后会生成一个<code>filename.js</code>的文件，包含了编译后的模板。</p>
<p>此时，我们在前端可以引入<code>runtime.js</code>,<code>filename.js</code>,然后通过js调用<code>filename.js</code>中函数，并传入参数(如果需要)，将会渲染出我们需要的html代码。</p>
<h2 id="u8FDB_u9636_B7_u81EA_u52A8_u9884_u7F16_u8BD1jade_u6A21_u677F"><a href="#u8FDB_u9636_B7_u81EA_u52A8_u9884_u7F16_u8BD1jade_u6A21_u677F" class="headerlink" title="进阶·自动预编译jade模板"></a>进阶·自动预编译jade模板</h2><p>以上方法都是手工编译，当我们原始模板改变之后，需要手工运行命令进行编译。这样极不方便，并且线上环境也不允许这样操作。</p>
<p>将预编译写成一工具类(<code>app/utils/jade-util.js</code>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jade = <span class="built_in">require</span>(<span class="string">'jade'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> _cwd = process.cwd();</span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sourcePath = _cwd + <span class="string">'/views/pages'</span>;</span><br><span class="line"><span class="keyword">var</span> targetPath = _cwd + <span class="string">'/public/javascript/template'</span>;</span><br><span class="line"><span class="keyword">var</span> targetFileName = <span class="string">'jade-template.js'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compiler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mkdirSync(targetPath);</span><br><span class="line">    fs.readdir(sourcePath, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allFunctions = [];</span><br><span class="line">        _.forEach(files, <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> jsFunctionString = jade.compileFileClient(sourcePath + <span class="string">'/'</span> + file, &#123;name: path.basename(file, <span class="string">'.jade'</span>).replace(<span class="regexp">/-/g</span>, <span class="string">'_'</span>) + <span class="string">'_template'</span>&#125;);</span><br><span class="line">            allFunctions.push(jsFunctionString);</span><br><span class="line">        &#125;);</span><br><span class="line">        fs.writeFileSync(targetPath + <span class="string">'/'</span> + targetFileName, allFunctions.join(<span class="string">'\r\n'</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'compile jade template successfully: '</span> + targetPath + <span class="string">'/'</span> + targetFileName);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mkdirSync = <span class="function"><span class="keyword">function</span> (<span class="params">dirpath, mode</span>) </span>&#123;</span><br><span class="line">    dirpath.split(<span class="string">'\/'</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, cur</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> p = path.resolve(pre, cur);</span><br><span class="line">        <span class="keyword">if</span> (!fs.existsSync(p)) fs.mkdirSync(p, mode || <span class="number">0755</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;, __dirname);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = compiler();</span><br></pre></td></tr></table></figure>
<p>以上代码意思是将项目目录下<code>views/pages</code>下的所有模板文件进行渲染，每个模板编译生成的函数名为<code>{filename}_template</code>，并且将所有生成的函数打包到项目目下下的<code>public/javascript/template</code>中的<code>jade-template.js</code>中。在客户端只需要引入此文件，并调用相应的函数即可生成指定html。</p>
<p>项目启动自动预编译</p>
<p>在<code>app.js</code>中插入以下代码</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./app/utils/jade-util'</span>);</span><br></pre></td></tr></table></figure>
<p>至此，每次启动项目时均会预编译所有指定jade模板文件。</p>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果使用以下监视文件并重启项目的工具时，需要将编译目标文件夹忽略掉（本例为<code>public/javascript/template</code>），否则会无限重启。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Jade 是一个高性能的模板引擎，它深受 <a href="http://haml-lang.com">Haml</a> 影响，它是用 JavaScript 实现的, 并且可以供 <a href="http://nodejs.org">Node</a> 使用.</p>
<blockquote>
<p>由于版权原因，jade更名为pug，详见<a href="https://github.com/pugjs/jade/issues/2184">issue</a></p>
</blockquote>
<p>本文不介绍如何在node端使用jade,具体使用方法可见官方文档或express文档。</p>
<p>在某些情况下，我们并不需要总是在后端去渲染模板。比如当我们编写一篇文章而又没有写完时，我们仅仅是想看一下预览效果，不希望去请求服务端保存，这时就要求预览的模板与样式与我们后端的一样，这种情况下就用到了在浏览器端进行渲染。</p>]]>
    
    </summary>
    
      <category term="browser" scheme="http://www.dullong.com/tags/browser/"/>
    
      <category term="jade" scheme="http://www.dullong.com/tags/jade/"/>
    
      <category term="pug" scheme="http://www.dullong.com/tags/pug/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <link href="http://www.dullong.com/Git-Cheat-Sheet-Chinese.html"/>
    <id>http://www.dullong.com/Git-Cheat-Sheet-Chinese.html</id>
    <published>2015-11-22T04:59:33.000Z</published>
    <updated>2016-01-01T15:20:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">ssh</span>://user@domain.com/repo.git</span><br></pre></td></tr></table></figure></p>
<p>创建一个新的本地仓库:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<h3 id="u672C_u5730_u4FEE_u6539"><a href="#u672C_u5730_u4FEE_u6539" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git status</span><br></pre></td></tr></table></figure></p>
<p>显示与上次提交版本文件的不同：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git diff</span><br></pre></td></tr></table></figure></p>
<p>把当前所有修改添加到下次提交中：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add </span>.</span><br></pre></td></tr></table></figure></p>
<p>把对某个文件的修改添加到下次提交中：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">add</span> -p &lt;<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>提交本地的所有修改：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -<span class="literal">a</span></span><br></pre></td></tr></table></figure></p>
<p>提交之前已标记的变化：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit</span><br></pre></td></tr></table></figure></p>
<p>附加消息提交：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">'message here'</span></span></span><br></pre></td></tr></table></figure></p>
<p>Commit to some previous date:<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --date=<span class="string">"<span class="escape">`d</span>ate --date='n day ago'<span class="escape">`"</span> -am "</span>Commit Message<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>修改上次提交<br><br><em><sub>Don’t amend published commits!</sub></em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">commit</span> <span class="comment">--amend</span></span></span><br></pre></td></tr></table></figure></p>
<p>把当前分支中未提交的修改移动到其他分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">git</span> stash</span><br><span class="line"><span class="label">git</span> checkout <span class="keyword">branch2</span><br><span class="line"></span><span class="label">git</span> stash <span class="keyword">pop</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u641C_u7D22"><a href="#u641C_u7D22" class="headerlink" title="搜索"></a>搜索</h3><p>从当前目录的所有文件中查找文本内容：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git grep <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure></p>
<p>在某一版本中搜索文本：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git grep <span class="string">"Hello"</span> <span class="literal">v2</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="u63D0_u4EA4_u5386_u53F2"><a href="#u63D0_u4EA4_u5386_u53F2" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="command">log</span></span><br></pre></td></tr></table></figure></p>
<p>显示所有提交（仅显示提交的hash和message）：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="command">log</span> <span class="comment">--oneline</span></span><br></pre></td></tr></table></figure></p>
<p>显示某个用户的所有提交：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="command">log</span> <span class="comment">--author="username"</span></span><br></pre></td></tr></table></figure></p>
<p>显示某个文件的所有修改：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="command">log</span> -p &lt;<span class="type">file</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>谁，在什么时间，修改了文件的什么内容：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame &lt;<span class="type">file</span>&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="u5206_u652F_u4E0E_u6807_u7B7E"><a href="#u5206_u652F_u4E0E_u6807_u7B7E" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有的分支：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch</span><br></pre></td></tr></table></figure></p>
<p>切换分支：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="tag">&lt;<span class="title">branch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>基于当前分支创建新分支：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;<span class="keyword">new</span>-branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>基于远程分支创建新的可追溯的分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>--track &lt;new-<span class="keyword">branch&gt; </span>&lt;remote-<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>删除本地分支:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d &lt;<span class="keyword">branch&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>给当前版本打标签：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">&lt;tag-name</span>&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="u66F4_u65B0_u4E0E_u53D1_u5E03"><a href="#u66F4_u65B0_u4E0E_u53D1_u5E03" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出对当前远程端的操作：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure></p>
<p>显示远程端的信息：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show <span class="tag">&lt;<span class="title">remote</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>添加新的远程端：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add <span class="tag">&lt;<span class="title">remote</span>&gt;</span> <span class="tag">&lt;<span class="title">url</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下载远程端版本，但不合并到HEAD中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch <span class="tag">&lt;<span class="title">remote</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下载远程端版本，并自动与HEAD版本合并：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote pull <span class="tag">&lt;<span class="title">remote</span>&gt;</span> <span class="tag">&lt;<span class="title">url</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>将远程端版本合并到本地版本中：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure></p>
<p>将本地版本发布到远程端：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push remote <span class="tag">&lt;<span class="title">remote</span>&gt;</span> <span class="tag">&lt;<span class="title">branch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>删除远程端分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">push </span>&lt;remote&gt; :&lt;<span class="keyword">branch&gt; </span>(since Git <span class="literal">v1</span>.<span class="number">5</span>.<span class="number">0</span>)</span><br><span class="line"><span class="label">or</span></span><br><span class="line"><span class="label">git</span> <span class="keyword">push </span>&lt;remote&gt; --delete &lt;<span class="keyword">branch&gt; </span>(since Git <span class="literal">v1</span>.<span class="number">7</span>.<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>发布标签:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push <span class="comment">--tags</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="u5408_u5E76_u4E0E_u91CD_u7F6E"><a href="#u5408_u5E76_u4E0E_u91CD_u7F6E" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge <span class="tag">&lt;<span class="title">branch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>将当前HEAD版本重置到分支中:<br><br><em><sub>Don’t rebase published commit!</sub></em><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase <span class="tag">&lt;<span class="title">branch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>退出重置:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase <span class="comment">--abort</span></span><br></pre></td></tr></table></figure></p>
<p>解决冲突后继续重置：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --<span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<p>使用配置好的merge tool 解决冲突：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git mergetool</span><br></pre></td></tr></table></figure></p>
<p>在编辑器中手动解决冲突后，标记文件为<code>已解决冲突</code><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">add</span> &lt;resolved-<span class="built_in">file</span>&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> &lt;resolved-<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u64A4_u9500"><a href="#u64A4_u9500" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard HEAD</span></span></span><br></pre></td></tr></table></figure></p>
<p>移除缓存区的所有文件（i.e. 撤销上次<code>git add</code>）:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">reset</span> <span class="keyword">HEAD</span></span></span><br></pre></td></tr></table></figure></p>
<p>放弃某个文件的所有本地修改：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD &lt;<span class="type">file</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>重置一个提交（通过创建一个截然不同的新提交）<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">revert </span>&lt;commit&gt;</span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并放弃之后的所有修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">reset</span> <span class="comment">--hard &lt;commit&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">reset</span> &lt;<span class="keyword">commit</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="operator"><span class="keyword">reset</span> <span class="comment">--keep &lt;commit&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>来源： <a href="https://raw.githubusercontent.com/flyhigher139/Git-Cheat-Sheet/master/Git%20Cheat%20Sheet-Zh.md" target="_blank" rel="external">https://raw.githubusercontent.com/flyhigher139/Git-Cheat-Sheet/master/Git%20Cheat%20Sheet-Zh.md</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">ssh</span>://user@domain.com/repo.git</span><br></pre></td></tr></table></figure></p>
<p>创建一个新的本地仓库:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[install dd-wrt and astrill into netgear r6300]]></title>
    <link href="http://www.dullong.com/install-dd-wrt-and-astrill-into-netgear-r6300.html"/>
    <id>http://www.dullong.com/install-dd-wrt-and-astrill-into-netgear-r6300.html</id>
    <published>2015-08-23T14:54:30.000Z</published>
    <updated>2015-12-31T18:23:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Step_1-_install_DD-WRT"><a href="#Step_1-_install_DD-WRT" class="headerlink" title="Step 1. install DD-WRT"></a>Step 1. install DD-WRT</h2><p>The whole detail can refer to <a href="http://www.dd-wrt.com/wiki/index.php/Netgear_R6300v2" target="_blank" rel="external">Netgear_R6300v2</a></p>
<h2 id="Step_2-_open_ssh_for_DD-WRT_and_set_no_crossdetect_is_true"><a href="#Step_2-_open_ssh_for_DD-WRT_and_set_no_crossdetect_is_true" class="headerlink" title="Step 2. open ssh for DD-WRT and set no_crossdetect is true"></a>Step 2. open ssh for DD-WRT and set no_crossdetect is true</h2><ol>
<li><p>connect to your router and set sshd enabled.</p>
</li>
<li><p>go to telnet/ssh console and type <code>nvram set no_crossdetect=1 nvram commit</code></p>
</li>
</ol>
<p>refer:<a href="http://svn.dd-wrt.com/ticket/1483" target="_blank" rel="external">Would like ability to turn off “Cross Site Action detected” error</a>  </p>
<p>note: the feature is introduced in <a href="http://svn.dd-wrt.com/changeset/14962" target="_blank" rel="external">r14962</a>. to prevent bad configs , i will not implement it as gui configurable feature.</p>
<h2 id="Step_3-_install_astrill_vpn"><a href="#Step_3-_install_astrill_vpn" class="headerlink" title="Step 3. install astrill vpn"></a>Step 3. install astrill vpn</h2><ol>
<li><p>login your astrill account,if you have no astrill account ,you need reg one first.</p>
</li>
<li><p>go <a href="https://members.astrill.com/router-setup.php" target="_blank" rel="external">router setup</a> and select your firmware as DD-WRT and edit your router ip.</p>
</li>
<li><p>click install button,and the astrill code will install to your dd-wrt router system.</p>
</li>
</ol>
<h2 id="Step_4-_configure_astrill"><a href="#Step_4-_configure_astrill" class="headerlink" title="Step 4. configure astrill"></a>Step 4. configure astrill</h2><ol>
<li><p>login to your router</p>
</li>
<li><p>select the <code>status</code> tab and then click <code>MyPage</code> tab,and it will in astrill configure page</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Step_1-_install_DD-WRT"><a href="#Step_1-_install_DD-WRT" class="headerlink" title="Step 1. install DD-WRT"></a>Step 1. install DD-W]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Google Appengine上部署应用的几种方式]]></title>
    <link href="http://www.dullong.com/several-ways-to-deploy-applications-on-Google-Appengine.html"/>
    <id>http://www.dullong.com/several-ways-to-deploy-applications-on-Google-Appengine.html</id>
    <published>2013-09-03T17:55:42.000Z</published>
    <updated>2015-12-31T18:13:02.000Z</updated>
    <content type="html"><![CDATA[<p>对于想使用云平台活着体验一下云平台的用户来说， google的appengine是一个不错的选择。 它提供了强大的功能和几乎免费的实例。对于学习来说绰绰有余。下面来简单介绍一下将自己的应用部署到appengine上的几种方法。</p>
<p>总体来说，有两种方法：直接通过google提供的上传脚本和通过eclipse的插件两种方法来上传。</p>
<a id="more"></a>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>下载和安装java环境，下载Tomcat 6，可baidu或Google，不再赘述</p>
</li>
<li><p>下载 appengine sdk，我的版本为 appengine-java-sdk-1.7.4，作用提供模拟云环境及上传等功能。</p>
</li>
<li><p>文本编辑器，如 notepad++ 等。</p>
</li>
<li><p>一个已经编写成功的web应用（符合appengine规范）</p>
</li>
</ul>
<h3 id="u901A_u8FC7google_SDK_u4E2D_u7684_u63D2_u4EF6_u8FDB_u884C_u4E0A_u4F20"><a href="#u901A_u8FC7google_SDK_u4E2D_u7684_u63D2_u4EF6_u8FDB_u884C_u4E0A_u4F20" class="headerlink" title="通过google SDK中的插件进行上传"></a>通过google SDK中的插件进行上传</h3><p>将appengine-java-sdk-1.7.4解压，并将其bin目录加入环境变量,定位到应用文件夹,执行命令 （其中WebContent为项目目录）<code>appcfg.cmd update WebContent</code>即可将WebContent作为项目文件夹上传上去。</p>
<h3 id="u4F7F_u7528eclipse_u63D2_u4EF6_u8FDB_u884C_u4E0A_u4F20"><a href="#u4F7F_u7528eclipse_u63D2_u4EF6_u8FDB_u884C_u4E0A_u4F20" class="headerlink" title="使用eclipse插件进行上传"></a>使用eclipse插件进行上传</h3><p>如果使用Eclipse，最简便的 App Engine 应用程序开发、测试和上传方法是使用Eclipse 插件。该插件包含完全在 Eclipse 中构建、测试和部署应用程序所需的所有功能。</p>
<p>该插件适用于 Eclipse 3.3、3.4 和 3.5 版。您可以使用 Eclipse 的“软件更新”功能安装该插件。安装位置如下所示：</p>
<ul>
<li>用于 Eclipse 3.3 (Europa) 的 Eclipse Google 插件：<a href="http://dl.google.com/eclipse/plugin/3.3" target="_blank" rel="external">http://dl.google.com/eclipse/plugin/3.3</a></li>
<li>用于 Eclipse 3.4 (Ganymede) 的 Eclipse Google 插件：<a href="http://dl.google.com/eclipse/plugin/3.4" target="_blank" rel="external">http://dl.google.com/eclipse/plugin/3.4</a></li>
<li>用于 Eclipse 3.5 (Galileo) 的 Eclipse Google 插件：<a href="http://dl.google.com/eclipse/plugin/3.5" target="_blank" rel="external">http://dl.google.com/eclipse/plugin/3.5</a></li>
</ul>
<p>具体安装步骤同其他常用插件一样，如若不懂请自行google之</p>
<h4 id="u521B_u5EFA_u4E00_u4E2AGoogle_Appengine_u9879_u76EE"><a href="#u521B_u5EFA_u4E00_u4E2AGoogle_Appengine_u9879_u76EE" class="headerlink" title="创建一个Google Appengine项目"></a>创建一个Google Appengine项目</h4><ul>
<li><p>选择文件菜单 &gt; 新建 &gt; 网络应用程序项目（如果没有看到该菜单选项，请选择窗口菜单 &gt; 重置视角…，点击确定，然后再次尝试选择文件菜单）。或者，点击工具栏中的“新建网络应用程序项目”按钮：“新建网络应用程序项目”按钮。</p>
</li>
<li><p>将打开“创建网络应用程序项目”向导。在“项目名称”中输入项目的名称，</p>
</li>
<li><p>如果使用软件更新功能安装 App Engine SDK，则已将插件配置为使用安装的 SDK。如果要使用单独的 App Engine SDK 安装，请点击配置 SDK…，然后按照提示在 SDK 的 appengine-java-sdk/ 目录中添加配置。</p>
</li>
<li><p>点击完成以创建项目。</p>
</li>
<li><p>编写项目代码（同普通java ee代码一样。只是做了一些限制，比如不能创建新等等对安全有隐患的操作之类）</p>
</li>
</ul>
<h4 id="u5C06_u9879_u76EE_u4E0A_u4F20_u5230google_Appengine_u4E0A"><a href="#u5C06_u9879_u76EE_u4E0A_u4F20_u5230google_Appengine_u4E0A" class="headerlink" title="将项目上传到google Appengine上"></a>将项目上传到google Appengine上</h4><ul>
<li><p>Google Eclipse 插件在 Eclipse 工具栏中添加了几个按钮。App Engine 部署按钮用于将应用程序上传到 App Engine：App Engine 部署按钮。</p>
</li>
<li><p>第一次上传应用程序之前，必须使用控制台在 App Engine 中注册应用程序 ID。注册一个应用程序 ID，然后编辑 appengine-web.xml 文件并更改 <application>…</application> 元素以包含新 ID。</p>
</li>
<li><p>在点击 App Engine 部署按钮时，Eclipse 将提示您输入管理员帐户用户名（您的电子邮件地址）和密码。输入您的帐户信息，然后点击上传按钮以完成上传。Eclipse 将从appengine-web.xml 文件中获取应用程序 ID 和版本信息，然后上传 war/ 目录内容。</p>
</li>
<li><p>通过访问应用程序网址，在 App Engine 上测试应用程序：<code>http://应用ID.appspot.com/项目名</code></p>
</li>
</ul>
<h2 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developers.google.com/appengine/docs/java/tools/uploadinganapp?hl=zh-cn" target="_blank" rel="external">https://developers.google.com/appengine/docs/java/tools/uploadinganapp?hl=zh-cn</a><br><a href="https://developers.google.com/appengine/docs/java/tools/eclipse?hl=zh-cn" target="_blank" rel="external">https://developers.google.com/appengine/docs/java/tools/eclipse?hl=zh-cn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于想使用云平台活着体验一下云平台的用户来说， google的appengine是一个不错的选择。 它提供了强大的功能和几乎免费的实例。对于学习来说绰绰有余。下面来简单介绍一下将自己的应用部署到appengine上的几种方法。</p>
<p>总体来说，有两种方法：直接通过google提供的上传脚本和通过eclipse的插件两种方法来上传。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[小序Cloudcmp的network(网络任务)]]></title>
    <link href="http://www.dullong.com/introduces-cloudcmp-network.html"/>
    <id>http://www.dullong.com/introduces-cloudcmp-network.html</id>
    <published>2013-05-13T01:14:42.000Z</published>
    <updated>2016-01-01T15:20:20.000Z</updated>
    <content type="html"><![CDATA[<p>Cloudcmp 具有的三个重要的测试任务分别是：计算、存储和网络。而在本片文章中主要介绍一下其关于网络性能测试的任务。    </p>
<p>对于网络性能，主要是通过tcp吞吐量和延迟来衡量的，因此本部分也是通过测量这两方面的性能来评测不同云平台的网络性能的。</p>
<p>以下分别对带宽和延迟来分别说明</p>
<a id="more"></a>
<h2 id="u5EF6_u8FDF"><a href="#u5EF6_u8FDF" class="headerlink" title="延迟"></a>延迟</h2><p>对于所有的任务来说，每个实现类均集成了基类Task，并实现重写了一些一些方法，而对于重写的方法来说，run()方法是最核心的一个方法。我们这里并不对他类是怎么写的来说明，仅仅说明其是如何实现的这一对延迟进行测量的方法。</p>
<p>核心代码如下：</p>
<pre><code>InetSocketAddress sockAddr = new InetSocketAddress(targetAddr, targetPort);
// try connect
Socket s = new Socket();
long startTime = System.nanoTime();
long duration;
s.connect(sockAddr);
duration = (System.nanoTime() - startTime) / 1000; // in microseconds
s.close();
</code></pre><p>其中，targetAddr和targetPort分别为地址的ip和端口号，而这一段的主要作用就是建立一个socket连接，并且连接成功所需要的时间，通过这个时间，并可以大概的计算出性能如何。通过多次进行这个方法并且求其平均值，便可以计算出某个云平台的网络延迟如何。</p>
<h2 id="u5E26_u5BBD"><a href="#u5E26_u5BBD" class="headerlink" title="带宽"></a>带宽</h2><p>核心代码如下：</p>
<pre><code>public long measureBandwidth(String targetAddr, long transferSize) throws IOException {
    int targetPort;
    if (!configs.containsKey(&quot;bw_port&quot;)) {
        return -1;
    }

    targetPort = Integer.parseInt(configs.get(&quot;bw_port&quot;));        

    InetSocketAddress sockAddr = new InetSocketAddress(targetAddr, targetPort);

    Socket s = new Socket();
    s.setTcpNoDelay(true);
    s.setSendBufferSize(8000000); // 8MB send buffer, enough for wide-area transfer
    byte [] buffer = new byte[8000000];
    long startTime;
    long duration;
    try {
        s.connect(sockAddr);
        long transferred = 0;
        InputStream is = s.getInputStream();
        OutputStream os = s.getOutputStream();

        byte [] transferSizeBytes = ByteBuffer.allocate(8).putLong(transferSize).array();            
        os.write(transferSizeBytes); // first tell the destination how many bytes we are going to send
        os.flush();

        startTime = System.nanoTime();
        while (transferred &lt; transferSize) {
            os.write(buffer);
            transferred += buffer.length;
        }
        os.flush();
        is.read(); // waiting for all bytes to be received by the destination
        duration = System.nanoTime() - startTime;
        s.close();
    }
    catch (IOException ex) {
        throw ex;
    }
    catch (Exception ex) {
        ex.printStackTrace();
        return -1;
    }

    return (long)(transferSize * 8 / ((double)duration / 1000000000));
}
</code></pre><p>关于带宽的计算上面，用到了与计算延迟相同的方法，只是对于延迟，不需要传输数据，而带宽则是通过多次进行传输一固定数据 transferSize ，获取操作时间来计算带宽的。关于带宽的计算公式为：带宽=传输大小*8/时间</p>
<p>由上看来，关于Cloudcmp的网络性能方面，其做的并不是太复杂，由此可见，一个大的工程并不是都是复杂的东西堆砌出来的，对于复杂的问题，都是一个一个简单的问题组成的，当简单的问题解决了，复杂的也就自然而然的解决了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Cloudcmp 具有的三个重要的测试任务分别是：计算、存储和网络。而在本片文章中主要介绍一下其关于网络性能测试的任务。    </p>
<p>对于网络性能，主要是通过tcp吞吐量和延迟来衡量的，因此本部分也是通过测量这两方面的性能来评测不同云平台的网络性能的。</p>
<p>以下分别对带宽和延迟来分别说明</p>]]>
    
    </summary>
    
  </entry>
  
</feed>
